import _ from 'lodash';
import ConstructorStore from './ConstructorStore';
import { Deserializer, Serializer, BaseConstructor } from '{{binaryTransferPath}}';

const header = Buffer.allocUnsafe(4);
header.writeUInt32LE(460212315, 0);

class Vector extends BaseConstructor {
    static _id = header.readUInt32LE(0);
    static _name = 'vector';
    static _type = 'Vector';

    constructor(options) {
        super();

        this._id = header.readUInt32LE(0);
        this._name = 'vector';
        this.type = options.type;
        this.items = options.items;
    }

    {% for method in nativeArrayMethods %}
    {{method}}(...args) {
        return this.items['{{method}}'](...args);
    }
    {% endfor %}

    {% for method in lodashMethods %}
    {{method}}(...args) {
        return _['{{method}}'](this.items, ...args);
    }
    {% endfor %}

    toJSON() {
        return this.items;
    }

    serialize() {
        const items = new Array(this.items.length);

        switch(this.type) {
        {% for type, method in generics %}
        case '{{ type }}':
            for(let i = 0; i < items.length; i++) {
                items[i] = this.items[i];
            }
            break;
        {% endfor %}
        default:
            for(let i = 0; i < items.length; i++) {
                items[i] = this.items[i].serialize();
            }
        }

        return Vector.encode({
            type: this.type,
            items: items
        });
    }

    static encode(options) {
        const serializer = new Serializer();

        // write vector header
        serializer.addBuffer(header);

        const length = options.items.length;

        serializer.writeUInt(length);

        for(let i = 0; i < length; i++) {
            switch(options.type) {
            {% for type, method in generics %}
            case '{{type}}':
                serializer.write{{method}}(options.items[i]);
                break;
            {% endfor %}
            default:
                serializer.addBuffer(options.items[i]);
            }
        }

        return serializer.getBuffer();
    }

    static decode(options) {
        const deserializer = options.hasOwnProperty('deserializer') ? options.deserializer : new Deserializer(options.buffer);
        const header = deserializer._readBytes(4);

        if(!header.equals(header)) {
            this.onError(
                'Invalid header for vector. Expected %s but got %s',
                this._id,
                header.readUInt32LE(0)
            );
            return false;
        }

        const length = deserializer.readUInt();
        const array = new Array(length);

        switch(options.type) {
        {% for type, method in generics %}
        case '{{type}}':
            for(let i = 0; i < length; i++) {
                array[i] = deserializer.read{{method}}();
            }
            break;
        {% endfor %}
        default:
            let Constructor;

            if(length > 0) {
                if(BaseConstructor.isConstructorReference(options.type)) {
                    Constructor = ConstructorStore.findConstructorFromName(options.type);
                } else if(BaseConstructor.isTypeReference(options.type)) {
                    // get first constructor header
                    Constructor = ConstructorStore.findConstructorFromBuffer(deserializer.buffer.slice(deserializer.offset));
                } else {
                    this.onError('Invalid type name: %s', options.type);
                    return false;
                }

                if(!Constructor) {
                    this.onError('Cannot find constructor for type: %s', options.type);
                    return false;
                }
            }

            for(let i = 0; i < length; i++) {
                array[i] = Constructor.deserialize(deserializer);
            }
        }

        return new Vector({
            type: options.type,
            items: array
        });
    }
}

module.exports = Vector;
