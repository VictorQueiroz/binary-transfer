import _ from 'lodash';
import ConstructorStore from './ConstructorStore';
import { Deserializer, Serializer } from '{{binaryTransferPath}}';

const ctorHeaderBytes = Buffer.alloc(4);
ctorHeaderBytes.writeUInt32LE(460212315, 0);

class Vector {
    static _id = ctorHeaderBytes.readUInt32LE(0);
    static _name = 'vector';

    constructor(options) {
        this._id = ctorHeaderBytes.readUInt32LE(0);
        this._name = 'vector';
        this.type = options.type;
        this.items = options.items;
    }

    {% for method in nativeArrayMethods %}
    {{method}}(...args) {
        return Array.prototype['{{method}}'].call(this.items, ...args);
    }
    {% endfor %}

    {% for method in lodashMethods %}
    {{method}}(...args) {
        return _['{{method}}'](this.items, ...args);
    }
    {% endfor %}

    serialize() {
        return Vector.encode({
            type: this.type,
            items: this.items
        });
    }

    static encode(options) {
        const serializer = new Serializer();

        // write vector header
        serializer.addBuffer(ctorHeaderBytes);

        const length = options.items.length;

        serializer.writeUInt(length);

        for(let i = 0; i < length; i++) {
            switch(options.type) {
                {% for type, method in generics %}
                case '{{type}}':
                    serializer.write{{method}}(options.items[i]);
                    break;
                {% endfor %}
                default:
                    serializer.addBuffer(options.items[i]);
            }
        }

        return serializer.getBuffer();
    }

    static skipDots(name) {
        const i = name.indexOf('.');

        if(i > -1) {
            return this.skipDots(name.substring(i + 1));
        }

        return name;
    }

    static isConstructorReference(name){
        name = this.skipDots(name);

        return name && name[0] == name[0].toLowerCase();
    }

    static isTypeReference(name){
        name = this.skipDots(name);

        return name && name[0] == name[0].toUpperCase();
    }

    static decode(options) {
        const deserializer = options.hasOwnProperty('deserializer') ? options.deserializer : new Deserializer(options.buffer);
        const header = deserializer._readBytes(4);

        if(!header.equals(ctorHeaderBytes)) {
            this.onError('Expected ' + ctorHeaderBytes.readUInt32LE(0) + ' but got ' + header.readUInt32LE(0));
            return false;
        }

        const length = deserializer.readUInt();
        const array = new Array(length);

        switch(options.type) {
        {% for type, method in generics %}
            case '{{type}}':
                for(let i = 0; i < length; i++) {
                    array[i] = deserializer.read{{method}}();
                }
                break;
        {% endfor %}
            default:
                let Constructor;

                if(Vector.isConstructorReference(options.type)) {
                    Constructor = ConstructorStore.findConstructorFromName(options.type);
                } else if(Vector.isTypeReference(options.type)) {
                    // get first constructor header
                    Constructor = ConstructorStore.findConstructorFromBuffer(deserializer.buffer.slice(deserializer.offset));
                } else {
                    this.onError('Invalid type name: %s', options.type);
                    return false;
                }

                if(!Constructor) {
                    this.onError('Cannot find constructor for type: %s', options.type);
                    return false;
                }

                for(let i = 0; i < length; i++) {
                    array[i] = Constructor.deserialize(deserializer);
                }
        }

        return new Vector({
            type: options.type,
            items: array
        });
    }
}

module.exports = Vector;
